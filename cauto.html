<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>CAuto by lehmann7</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <!--script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script-->
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
    <div id="header">
      <nav>
        <li class="fork"><a href="https://github.com/lehmann7">View On GitHub</a></li>
        <li class="downloads"><a href="https://github.com/lehmann7/cauto/zipball/master">ZIP</a></li>
        <li class="downloads"><a href="https://github.com/lehmann7/cauto/tarball/master">TAR</a></li>
      </nav>
    </div>

    <div class="wrapper">
      <section>
        <div id="title">
          <h1>CAuto</h1>
          <p>Automatic Compile And Link C++ Projects</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/lehmann7">lehmann7</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

       <div id="content">
<h1>Introduction</h1>

<p>CAuto is a simple command line tool for <em>automatic compile and link C++ projects</em>.  </p>

<p>CAuto aims at speeding up the workflow when managing targets and source code in a C++ project. Thus, CAuto uses an easy naming convention to automatically setup executables and libraries by scanning your source tree. Just drop in your files, configure dependencies and build.  </p>

<p>Using CAuto doesnt keep you off the important work - implementing your project. Create new targets for executables and libraries is as easy as creating a new file and run CAuto.  </p>

<p>CAuto relies on <em>bash</em>, <em>CMake</em> and <em>g++</em>.  </p>

<ul>
<li><em>bash</em>  is used to run CAuto.  </li>
<li><em>CMake</em> manages dependencies (scans headers and uses <em>FindPackage.cmake</em> scripts).  </li>
<li><em>g++</em>   is used to scan source files.  </li>
</ul>

<p>CAuto is in development. Many things need to be extended and moved to config files. However it already can be used to setup C++ executables and libraries with only a few commands on the command line. It works and is simple.  </p>

<p>Feedback and contributions are welcome.  </p>

<h1>Using CAuto</h1>

<h2>Install</h2>

<p>CAuto only consists of a script and a CMake file. To install simply do:  </p>

<blockquote>
  <p>$<code>git clone https://github.com/lehmann7/cauto</code> <br />
$<code>cd cauto</code> <br />
$<code>make PREFIX=/usr/local install</code>  </p>
</blockquote>

<p>or if you only want to see whats going to happen do:  </p>

<blockquote>
  <p>$<code>make -n PREFIX=/usr/local install</code>  </p>
</blockquote>

<p>After installation test if CAuto is in your path:  </p>

<blockquote>
  <p>$<code>cauto</code>  </p>
</blockquote>

<p>This should print the help page of CAuto.  </p>

<h2>Setup Project</h2>

<p>To setup a project at first create a new folder and then use Cauto to init the project:  </p>

<blockquote>
  <p>$<code>mkdir myproj</code> <br />
$<code>cd myproj</code> <br />
$<code>cauto init</code>  </p>
</blockquote>

<p>Now the project is initialized and looks like this:  </p>

<blockquote>
  <p>$<code>ls</code> <br />
<code>build/</code> <br />
<code>conf/</code> <br />
<code>CMakeLists.txt</code>  </p>
</blockquote>

<p><code>build/</code> will contain all compiled binaries (object files, executables, libraries) and <code>conf/</code> the project configuration (compiler flags, linker flags and dependencies).  </p>

<h2>Setup Source Tree</h2>

<p>The source tree consists of four folders:  </p>

<ul>
<li><code>inc/</code> - include dir, headers of the project  </li>
<li><code>src/</code> - source dir, implementation  </li>
<li><code>exe/</code> - executable dir  </li>
<li><code>so/</code> - library dir  </li>
</ul>

<p>Depending on where you put a file, it is going to be compiled into an object file, an executable or a library.  </p>

<p>Files in <code>src/</code> and <code>inc/</code> are compiled into object files and used to link executables and libraries. Object files are handled by CMake in <code>build/CMakeFiles/*</code>. In order to tell CAuto a header file corresponds to a certain source file, the basename of both files relative to <code>inc/</code> and <code>src/</code> has to be the same. For example if a target includes <code>inc/foo/bar.h</code>, the target will be compiled with <code>src/foo/bar.cpp</code> in the case it exists.  </p>

<p>Executables and libraries are created in <code>build/</code> using the same basename of the file relative to <code>exe/</code> or <code>so/</code>. For example <code>exe/foo/bar.cpp</code> is compiled into the binary <code>build/foo/bar</code> and <code>src/bar/foo.cpp</code> is compiled into the binary <code>build/bar/libfoo.so</code>.  </p>

<h3>Example Executable</h3>

<p>Lets make an example executable and enable C++11:  </p>

<blockquote>
  <p>$<code>echo "MyProject" &gt;&gt; conf/project</code> <br />
$<code>echo "-std=c++11" &gt;&gt; conf/cxxflags</code> <br />
$<code>mkdir -p exe/filesystem</code> <br />
$<code>wget -O exe/filesystem/simple_ls.cpp http://lehmann7.github.io/example/simple_ls.cpp</code> <br />
$<code>cauto scan</code>  </p>
</blockquote>

<p>Now CAuto tells you some information about the project and that it has found a new target <code>filesystem_simple_ls</code> which corresponds to the source file <code>exe/filesystem/simple_ls.cpp</code>.  </p>

<p>Using <code>cauto make</code> you can build the executable. However it will not work, since <em>boost::filesystem</em> is not header-only and needs to be linked against a shared object. Since setting build configuration manually is annoying, CAuto uses CMake find scripts to configure compile and link dependencies.  </p>

<p>To tell CAuto to use <em>boost::filesystem</em> just do the following:  </p>

<blockquote>
  <p>$<code>echo "ADD_PACKAGE(Boost Boost REQUIRED COMPONENTS system filesystem)" &gt;&gt; conf/package.cmake</code> <br />
$<code>echo "Boost" &gt;&gt; conf/filesystem/package</code> <br />
$<code>cauto scan make</code>  </p>
</blockquote>

<p>Now the target <code>filesystem_simple_ls</code> should compile and link into <code>build/filesystem/simple_ls</code>. The configuration mechanism of CAuto is explained in the section <em>Configure Project</em> below.  </p>

<h3>Example Library</h3>

<p>After we have created an example executable, lets extend the project by an example library:  </p>

<blockquote>
  <p>$<code>mkdir -p inc/mymath</code> <br />
$<code>mkdir -p src/mymath</code> <br />
$<code>mkdir -p so/mymath</code> <br />
$<code>wget -O inc/mymath/factorial.h http://lehmann7.github.io/example/factorial.h</code> <br />
$<code>wget -O inc/mymath/crossprod3.h http://lehmann7.github.io/example/crossprod3.h</code> <br />
$<code>wget -O src/mymath/factorial.cpp http://lehmann7.github.io/example/factorial.cpp</code> <br />
$<code>wget -O src/mymath/crossprod3.cpp http://lehmann7.github.io/example/crossprod3.cpp</code> <br />
$<code>wget -O so/mymath/mymath.cpp http://lehmann7.github.io/example/mymath.cpp</code> <br />
$<code>cauto scan make</code>  </p>
</blockquote>

<p>Now CAuto rescans and builds the project. You can check the resulting shared object by:  </p>

<blockquote>
  <p>$<code>nm build/mymath/mymath.so | c++-filt | tail -n 2</code>  </p>
</blockquote>

<h2>Configure Project</h2>

<p>The project configuration is located in <code>conf/</code>. The configuration is based on the following files:  </p>

<ul>
<li><code>conf/project</code> - name of project  </li>
<li><code>conf/package.cmake</code> - external dependencies of project, use CMake find scripts  </li>
<li><code>conf/foo/bar/cxxflags</code> - additional compiler flags for all targets <code>foo_bar_*</code>  </li>
<li><code>conf/foo/bar/ldflags</code> - additional linker flags for all targets <code>foo_bar_*</code>  </li>
<li><code>conf/foo/bar/package</code> - packages to be used by targets for all targets <code>foo_bar_*</code>  </li>
<li><code>conf/foo/bar/&lt;NAME&gt;.cxxflags</code> - additional compiler flags for target <code>foo_bar_&lt;NAME&gt;</code>  </li>
<li><code>conf/foo/bar/&lt;NAME&gt;.ldflags</code> - additional linker flags for <code>foo_bar_&lt;NAME&gt;</code>  </li>
<li><code>conf/foo/bar/&lt;NAME&gt;.package</code> - packages to be used by targets for <code>foo_bar_&lt;NAME&gt;</code>  </li>
</ul>

<h3>Project Name</h3>

<p><code>conf/project</code> simply contains the name of the project and is passed to the CMake command <code>PROJECT(...)</code>. You can set it up by:  </p>

<blockquote>
  <p>$<code>echo "MyProjectName" &gt; conf/project</code>  </p>
</blockquote>

<h3>External Packages</h3>

<p><code>conf/package.cmake</code> contains CMake commands to setup external dependencies using CMake find scripts. To do so the command  </p>

<blockquote>
  <p><code>ADD_PACKAGE(&lt;VAR_SUFFIX&gt; &lt;FIND_PACKAGE_ARGS...&gt;)</code>  </p>
</blockquote>

<p>has to be used. <code>ADD_PACKAGE(...)</code> wraps the CMake command <code>FIND_PACKAGE(...)</code> and requires the find script to setup the following CMake variables:  </p>

<ul>
<li><code>&lt;VAR_SUFFIX&gt;_INCLUDE_DIRS</code> - include directories of package  </li>
<li><code>&lt;VAR_SUFFIX&gt;_LIBRARIES</code> - library of package  </li>
<li><code>&lt;VAR_SUFFIX&gt;_DEFINITIONS</code> - definitions of package  </li>
</ul>

<p>Notice that the <code>&lt;VAR_SUFFIX&gt;</code> is the first argument of <code>ADD_PACKAGE(...)</code>, whereas all the other arguments are directly passed to <code>FIND_PACKAGE(...)</code>. If a CMake find script does not define the variables in this manner, an additional file <code>conf/&lt;VAR_SUFFIX&gt;.cmake</code> has to be created which sets the variables using the find scripts custom output variables.  </p>

<p>Adding a some packages could look like this:  </p>

<blockquote>
  <p><code>ADD_PACKAGE(Boost Boost REQUIRED COMPONENTS system filesystem program_options)</code> <br />
<code>ADD_PACKAGE(VTK VTK REQUIRED)</code> <br />
<code>ADD_PACKAGE(OSG osg)</code>  </p>
</blockquote>

<h3>Target Configuration</h3>

<p>A configuration file located in <code>conf/foo/bar/</code> is applied to configure all executables in <code>exe/foo/bar/*</code> and libraries in <code>so/foo/bar/*</code>. Supported configuration files are <code>cxxflags</code>, <code>ldflags</code> and <code>package</code>. Each file is simply a list of string separated by white-space.  </p>

<p>In contrast the files <code>conf/foo/bar/&lt;NAME&gt;.cxxflags</code>, <code>conf/foo/bar/&lt;NAME&gt;.ldflags</code> and <code>conf/foo/bar/&lt;NAME&gt;.package</code> are used to configure the compiling and linking of the single target <code>foo_bar_&lt;NAME&gt;</code>.  </p>

<p>The <code>package</code> or <code>&lt;NAME&gt;.package</code> file contains a list of <code>&lt;VAR_SUFFIX&gt;</code> of the packages which are added to the project using <code>ADD_PACKAGE(...)</code> in <code>conf/package.cmake</code>.  </p>

<p>An example configuration which applies to all targets of the whole project could look like this:  </p>

<blockquote>
  <p>$<code>echo "-std=c++11" &gt; conf/cxxflags</code> <br />
$<code>echo "-Llib -lmylib" &gt; conf/ldflags</code> <br />
$<code>echo "Boost VTK OSG" &gt; conf/package</code>  </p>
</blockquote>
       </div>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>
</html>
